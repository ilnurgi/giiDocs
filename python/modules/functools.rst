.. py:module:: functools

functools
=========

Модуль содержит функции и декораторы, которые удобно использовать для создания высокоуровневых функций и декораторов в функциональном программировании.

.. py:function:: partial(function [, *args [, **kwargs]])
    
    Создает объект типа partial, напоминающий функцию, который при вызове обращается к функции function и передает ей позиционные аргументы args, именованные аргументы kwargs, а также любые дополнительные позиционные и именованные аргументы, переданные объекту при его вызове. Дополнительные позиционные аргументы добавляются в конец args, а дополнительные именованные аргументы добавляются в словарь kwargs, затирая ранее определенные значения с теми же ключами (если таковые имеются). Обычно функция partial() используется, когда требуется многократно вызвать одну и ту же функцию, большая часть аргументов которой остаются неизменными. Например:

    ::
    
        from functools import partial
        mybutton = partial(Button, root, fg=”black”,bg=”white”,font=”times”,size=”12”)
        b1 = mybutton(text=”Ok”)
        # Вызовет Button() с аргументами text=”Ok”
        
        b2 = mybutton(text=”Cancel”) 
        # и остальными, которые были переданы функции
        
        b3 = mybutton(text=”Restart”)
        # partial() выше
        
    Экземпляр p объекта, созданного функцией partial(), имеет следующие атрибуты:

    * `p.func` - функция, которая вызывается при вызове объекта p.
    * `p.args` - кортеж, содержащий первые позиционные аргументы, которые передаются функции p.func при вызове. Дополнительные позиционные аргументы добавляются в конец этого значения.
    * `p.keywords` - словарь, содержащий именованные аргументы, которые передаются функции p.func при вызове. Дополнительные именованные аргументы добавляются в этот словарь.

    Будьте внимательны при использовании объектов типа partial в качестве замены обычным функциям. Результат, возвращаемый объектом, будет отличаться от того, что возвращается обычной функцией. Например, если функцию partial() использовать внутри определения класса, полученный объект будет вести себя, как статический метод, а не как метод экземпляра.


.. py:method:: reduce(function, items [, initial])

    :param function: функция обработчик, принимает два параметра: накопленное и текущее значение
    :param items: итерируемый объект
    :param initial: начальное значение
    
    Применяет функцию к парам элементов в итерируемом объекте и возвращает единственное накопленное значение. Функция должна принимать два аргумента, накопленное и текущее значение.


.. py:method:: update_wrapper(wrapper, wrapped [, assigned [, updated]])
    
    Эту вспомогательную функцию удобно использовать при создании декораторов. Она копирует атрибуты функции wrapped в функцию-обертку wrapper, делая ее похожей на оригинальную функцию. В аргументе assigned передается кортеж с именами атрибутов для копирования, который по умолчанию имеет значение (‘__name__’,’__module__’,’__doc__’). В аргументе updated передается кортеж с именами атрибутов функции, являющихся словарями, значения из которых должны быть добавлены в функцию-обертку. По умолчанию является кортежем (‘__dict__’,).

.. py:method:: wraps(function [, assigned [, updated ]])
    
    Декоратор, который выполняет ту же задачу, что и декоратор update_wrapper(). Аргументы assigned и updated имеют такое же назначение. Обычно этот декоратор используется при создании других декораторов. Например:

    ::

        from functools import wraps
        def debug(func):
            @wraps(func)
            def wrapped(*args,**kwargs):
                print(“Вызывается %s” % func.__name__)
                r = func(*args,**kwargs)
                print(“Выполнен вызов %s” % func.__name__)
            return wrapped
        @debug
        def add(x,y):
            return x+y