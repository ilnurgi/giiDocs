.. py:module:: e32

e32
===

Модуль для работы с системными функциями

.. py:attribute:: pys60_version 
    
    Информация о версии питона
 
    >>> e32.pys60_version
    '2.0.0' 

.. py:attribute:: pys60_version_info 
    
    Более подробная информация о версии питона
    
    >>> e32.pys60_version_info    
    (2, 0, 0, 'final', 0)

.. py:attribute:: s60_version_info 
    
    Информация о версии SDK
        
        * (1,2) - Series 60 1st Edition
        * (2,0) - Series 60 2nd Edition
        * (2,6) - Series 60 2nd Edition Feature Pack 2
        * (2,8) - Series 60 2nd Edition Feature Pack 3
        * (3,0) - Symbian 9.1
        * (3,1) - Symbian 9.2
        * (3,2) - Symbian 9.3
        * (5,0) - Symbian 9.4
        * (5,3) - Symbian Belle
 
    >>> e32.s60_version_info
    (2,8)

.. py:method:: ao_callgate(wrapped_callable) 
    
    Возвращает объект-функцию (на основе функции wrapped_callable), которую можно вызвать из любого потока программы. Функция создает копию функции, которая не задерживает поток на момент его исполнения.

    >>> my_note = e32.ao_callgate(appuifw.note)
    >>> my_note(u'bla', 'info')

.. py:method:: ao_sleep(time [,callback]) 
    
    :param time: время спячки, сек
    :param callback: обработчик

    Программа засыпает на время
    
    >>> e32.ao_sleep(5)

.. py:method:: ao_yield() 
    
    Функция указывает планировщику обработать системные события. Не позволяет зависнуть программе, интенсивно работающей с данными, поэтому часто используется при осуществлении математических вычислений, в играх и работе с файлами. 

.. py:method:: drive_list() 
    
    Возвращает список дисков
    
    >>> e32.drive_list()
    [u'C:', u'D:', u'E:', u'Z:']

.. py:method:: file_copy(src, dst) 
    
    Копирует файл dst в папку src
 
    >>> e32.file_copy('e:\\','c:\1.txt\')

.. py:method:: get_capabilities() 
    
    Возвращает кортеж, капсы приложения
    
    >>> e32.get_capabilities()
    ('ReadUserData','WriteUserData')

.. py:method:: has_capabilities(caps) 
    
    Проверяет приложение, на наличие капсов caps
    
    >>> e32.has_capabilities('WriteUserData', 'ReadUserData')
    True

.. py:method:: in_emulator() 
    
    Функция возвращает 1, если программа запущена на эмуляторе, и 0 - если на смартфоне.
 
    >>> e32.in_emulator()
    1

.. py:method:: inactivity() 
    
    Возвращает время простоя смартфона в секундах
 
    >>> e32.inactivity()
    234

.. py:method:: is_ui_thread() 
    
    Функция возвращает 1, если код, который вызвал эту функцию, работает в контексте текущего пользовательского интерфейса, иначе функция возвращает 0. 

.. py:method:: reset_inactivity() 
    
    Обнуляет время простоя смартфона в секундах
    
    >>> e32.reset_inactivity()

.. py:method:: set_home_time(time) 
    
    Функция устанавливает новое системное время time (в секундах) 

.. py:method:: start_exe(filename, command, [, wait]) 

    Функция запускает программу по пути filename и передает ему параметр command, wait - имя функции, выполняемая при завершении работы запущенной программы и вернет одно из двух значений: 0 или 2, нормальный или ненормальный выход.
    
    >>> e32.start_exe('z:\\system\\programs\\apprun.exe', 'c:\\system\\apps\\python\\python.app')
    >>> wait_flag=1
    >>> url = "4 http://licensing.symbian.org/"
    >>> exit_type = e32.start_exe(application_exe,' "%s"' %url , wait_flag)

    >>> # Открыть html страницу с диска
    >>> path = "E:/data/saved pages/page.htm"
    >>> url = "file://" + path
    >>> e32.start_exe("BrowserNG.exe", " \"%s\"" % url)
    
    Префикс '4 'в URL указывает на то что браузер должен запустить указанный URL. Другие стандартные префиксы:

        * None <Любой текст> - Начать или продолжить работу браузера без указания содержания
        * 1<Пробел>+<Uid закладки> - Начать или продолжить работу браузера с указанной закладки
        * 2<Пробел>+<Uid сохраненной страницы> - Начать или продолжить браузера с сохраненной страницы
        * 3<Пробел>+<URL> - Начать или продолжить работу браузера с указанной URL
        * 4<Пробел>+<URL>+<Пробел>+<UID AP> - Начать или продолжить работу браузера с указанной закладки и точки доступа
        * 5<Любой текст> - Начать или продолжить работу браузера со стартовой страницы
        * 6<Пробел>+<UID закладки папки> - Начать или продолжить работу браузера с указанной папки закладок
        
        Также можно использовать суффиксы в URL:
        
        * B - это открытие программы в фоне
        * O - open (открытие файла)
        * R - read (чтение)
        * V - что-то вроде временного файла.

.. py:method:: start_server(filename) 
    
    Функция запускает программу filename (полный путь к файлу в виде строки) как отдельный процесс (т.е. не видно через «Диспетчер задач»). Программе, запущенной таким образом, запрещено использовать модуль appuifw. Обычно используется для создания сервисных процессов (не мозолящих глаза пользователю и выполняющих полезные функции в фоновом режиме) и сопровождаются программой-клиентом для его управления.

Ao_lock() 
---------

.. py:class:: Ao_lock() 

    Объект-«замок», способный прервать текущий процесс. Не блокируется обработка события текущего пользовательского интерфейса (т.е. программа по-прежнему будет реагировать на нажатия клавиш и т.д.) 

.. py:method:: Ao_lock.wait()
    
    метод прерывает выполнение текущего потока до того момента, пока не будет вызван метод :py:meth:`signal()` 

.. py:method:: Ao_lock.signal() 
    
    метод сигнализирует о том, что нужно продолжить работу.

Ao_timer() 
----------

.. py:class:: Ao_timer()

    Объект-таймер, задача которого заменить функцию :py:meth:`ao_sleep` там, где её использование нежелательно. Использование этого объекта также, как и :py:class:`Ao_lock`, обходится без блокировки обработки события текущего пользовательского интерфейса.

.. py:method:: Ao_timer.after(interval [,callback ])

    :param interval: время таймера (не более 2147 секунд)
    :param callback: обработчик завершения таймера
    
    метод прерывает выполнение текущего потока

.. py:method:: Ao_timer.cancel() 
    
    метод указывает досрочно выйти из «спячки» и продолжить работу

    >>> timer = e32.Ao_timer()
    >>> timer.after(1800, callback)
    >>> timer.cancel()